# Plugin Architecture Vision - Project-Adapted Commands

**Date**: 2025-12-27
**Status**: Architectural Roadmap
**Context**: User insight during context optimization session

---

## The Problem We're Solving

### Current Architecture (Bloated & Redundant)

```
Every Session Loads:
â”œâ”€ Global sc:* commands (~24k tokens)
â”‚  â”œâ”€ sc:implement (generic multi-framework)
â”‚  â”œâ”€ sc:task (generic coordination)
â”‚  â”œâ”€ sc:research (generic web research)
â”‚  â””â”€ 22 others...
â””â”€ Project commands (~20k tokens)
   â”œâ”€ /project:implement (Python TDD, scholardoc-specific)
   â”œâ”€ /project:improve (scholardoc workflow)
   â””â”€ 18 others...

Total: ~44k tokens with massive redundancy!
Problems:
- sc:implement (React/Vue focus) loaded in Python projects
- sc:task (generic) duplicates project-specific workflows
- One-size-fits-all approach wastes tokens
- No adaptation to project context
```

### Vision: Project-Adapted Commands

```
Each Project (Generated by /init):
â””â”€ .claude/commands/
   â”œâ”€ implement.md â† Tailored to THIS project's stack
   â”œâ”€ test.md      â† Tailored to THIS project's test framework
   â”œâ”€ improve.md   â† Tailored to THIS project's quality needs
   â”œâ”€ research.md  â† Tailored to THIS project's domain
   â””â”€ [others]     â† Only what THIS project needs

Global (Minimal):
â””â”€ ~/.claude/commands/sc/
   â”œâ”€ help.md  (2.0k) - Universal command reference
   â”œâ”€ load.md  (842)  - Universal session restore
   â””â”€ save.md  (867)  - Universal session persistence

Total per project: ~10-15k tokens (NO redundancy!)
Savings: ~20-30k tokens per session
```

---

## Core Principle

> **/init should analyze the project and generate commands perfectly adapted to that project's stack, workflow, and needs.**

**Not**: Load 25 global commands that work for every project
**Instead**: Generate 8-12 project-specific commands that work perfectly for THIS project

---

## Real-World Examples

### Python TDD Project (scholardoc)

```bash
cd ~/workspace/projects/scholardoc
claude
/init

# /init analyzes:
- Python 3.11+ detected
- pytest + hypothesis testing framework
- PyMuPDF library (PDF processing)
- spikes/ directory (exploration workflow)
- SPEC.md, ROADMAP.md, QUESTIONS.md (structured docs)
- TDD workflow in existing code

# /init generates .claude/commands/:
```

**Generated: implement.md**
```markdown
---
description: "Python TDD implementation workflow for scholardoc"
---

# Step 1: Understand
- Check SPEC.md for data models
- Check QUESTIONS.md for unresolved decisions
- Understand PDF processing context

# Step 2: Write Tests First (pytest)
```bash
uv run pytest tests/unit/<module>/test_<feature>.py -v
```

# Step 3: Implement with PyMuPDF patterns
- Follow existing PDF extraction patterns
- Graceful degradation for OCR failures

# Step 4: Run Spikes if Uncertain
- Use spikes/ for exploration before implementation
```

**Generated: research.md**
```markdown
---
description: "Academic PDF research for scholardoc domain"
---

Research academic papers on:
- PDF text extraction techniques
- OCR quality improvement methods
- Scholarly document processing

Focus: Academic sources, PDF processing research
```

---

### React Frontend Project

```bash
cd ~/workspace/projects/my-react-app
claude
/init

# /init analyzes:
- React 18 + TypeScript detected
- Jest + React Testing Library
- Storybook for component development
- Tailwind CSS design system
- package.json scripts

# /init generates .claude/commands/:
```

**Generated: implement.md**
```markdown
---
description: "React component implementation with Magic MCP"
mcp-servers: [magic, context7, playwright]
---

# Step 1: Component Spec
- Define props interface (TypeScript)
- Plan component state and behavior

# Step 2: Storybook Story First
```bash
npm run storybook
```
Create .stories.tsx with component variants

# Step 3: Implement with Magic MCP
Use Magic MCP for UI generation:
- Tailwind CSS classes
- Accessibility (ARIA labels)
- React best practices from Context7

# Step 4: Tests (Jest + React Testing Library)
```bash
npm test -- <ComponentName>.test.tsx
```
```

**Generated: research.md**
```markdown
---
description: "Frontend web technology research"
mcp-servers: [context7]
---

Research current best practices for:
- React patterns and hooks
- Frontend performance optimization
- Accessibility standards (WCAG)

Focus: Web development, React ecosystem, frontend tech
```

---

### Django API Project

```bash
cd ~/workspace/projects/my-django-api
claude
/init

# /init analyzes:
- Django 4.2 detected
- Django REST Framework
- PostgreSQL database
- pytest-django for testing
- Celery for background tasks

# /init generates .claude/commands/:
```

**Generated: implement.md**
```markdown
---
description: "Django REST API implementation workflow"
---

# Step 1: Design
- Define models in models.py
- Plan serializers and viewsets
- Update urls.py routing

# Step 2: Write Tests (pytest-django)
```bash
pytest tests/api/test_<endpoint>.py -v
```

# Step 3: Implement
- Create models, migrations
- Implement serializers (DRF)
- Create viewsets with permissions

# Step 4: Security Check
- Authentication required?
- Permission classes appropriate?
- SQL injection prevention?

# Step 5: Background Tasks (Celery if needed)
```

---

## Implementation Roadmap

### Phase 1: Template System

**Create Template Library**:
```
~/.claude/templates/
â”œâ”€ python-tdd/
â”‚  â”œâ”€ commands/
â”‚  â”‚  â”œâ”€ implement.md.template
â”‚  â”‚  â”œâ”€ test.md.template
â”‚  â”‚  â”œâ”€ research.md.template
â”‚  â”‚  â””â”€ spike.md.template
â”‚  â””â”€ metadata.json
â”œâ”€ react-frontend/
â”‚  â”œâ”€ commands/
â”‚  â”‚  â”œâ”€ implement.md.template
â”‚  â”‚  â”œâ”€ component.md.template
â”‚  â”‚  â”œâ”€ test.md.template
â”‚  â”‚  â””â”€ research.md.template
â”‚  â””â”€ metadata.json
â”œâ”€ django-api/
â”‚  â””â”€ ...
â””â”€ [other stacks]/
```

**Template Variables**:
```markdown
# {{PROJECT_NAME}}: {{COMMAND_NAME}}

Stack: {{DETECTED_STACK}}
Test Framework: {{TEST_FRAMEWORK}}
Primary Language: {{LANGUAGE}}
Domain: {{PROJECT_DOMAIN}}

{{#if HAS_SPIKES}}
## Exploration First
Run spike in spikes/ directory before implementing
{{/if}}

{{#if TEST_FRAMEWORK}}
## Testing
```bash
{{TEST_COMMAND}} tests/{{TEST_PATH}}
```
{{/if}}
```

### Phase 2: Detection Engine

**Rewrite /project:init with Smart Detection**:

```python
class ProjectAnalyzer:
    def detect_stack(self) -> ProjectStack:
        """Analyze project to determine stack."""

        # Language detection
        if exists('pyproject.toml') or exists('setup.py'):
            language = 'python'
            version = parse_python_version()
        elif exists('package.json'):
            language = 'javascript'
            framework = detect_js_framework()  # React, Vue, etc.

        # Framework detection
        if language == 'python':
            if 'django' in dependencies:
                framework = 'django'
            elif 'fastapi' in dependencies:
                framework = 'fastapi'
            elif 'flask' in dependencies:
                framework = 'flask'

        # Test framework
        test_framework = detect_test_framework()
        # pytest, jest, vitest, etc.

        # Workflow patterns
        has_spikes = exists('spikes/')
        has_spec = exists('SPEC.md')
        tdd_workflow = detect_tdd_patterns()

        # Domain detection
        domain = infer_domain()
        # academic, e-commerce, fintech, etc.

        return ProjectStack(
            language=language,
            framework=framework,
            test_framework=test_framework,
            has_spikes=has_spikes,
            domain=domain,
            tdd_workflow=tdd_workflow
        )

    def select_templates(self, stack: ProjectStack) -> list[Template]:
        """Select appropriate templates for this stack."""

        # Match to template library
        if stack.language == 'python' and stack.tdd_workflow:
            return templates['python-tdd']
        elif stack.framework == 'react':
            return templates['react-frontend']
        elif stack.framework == 'django':
            return templates['django-api']
        # etc.

    def generate_commands(self, templates: list[Template], stack: ProjectStack):
        """Generate .claude/commands/ from templates."""

        for template in templates:
            rendered = template.render(
                project_name=self.project_name,
                stack=stack,
                # Template variables
            )

            output_path = f'.claude/commands/{template.name}.md'
            write_file(output_path, rendered)
```

### Phase 3: Command Generation

**New /project:init Workflow**:

```markdown
# /project:init - Intelligent Project Onboarding

## Phase 1: Analyze
1. Detect language, framework, test framework
2. Identify workflow patterns (TDD, spikes, etc.)
3. Infer project domain
4. Detect MCP server needs

## Phase 2: Select Templates
1. Match project stack to template library
2. Identify required commands
3. Select MCP servers to enable

## Phase 3: Generate
1. Render templates with project variables
2. Write .claude/commands/*.md
3. Generate CLAUDE.md with progressive disclosure
4. Enable appropriate MCP servers

## Phase 4: Validate
1. Display generated commands to user
2. Confirm MCP server selections
3. Allow customization before finalizing

## Phase 5: Document
1. Create .claude/README.md explaining the setup
2. Document which templates were used
3. Provide guidance for extending commands
```

### Phase 4: Template Contribution System

**Allow Users to Create Templates**:

```bash
# Create new template
claude template create --name "my-stack"

# Define template structure
.claude/templates/my-stack/
â”œâ”€ commands/
â”‚  â”œâ”€ implement.md.template
â”‚  â””â”€ test.md.template
â”œâ”€ metadata.json
â””â”€ README.md

# Share template
claude template publish my-stack
# Publishes to community template registry
```

---

## Migration Path

### For Existing Projects

**Option 1: Re-init**
```bash
cd existing-project
claude
/init --regenerate
# Analyzes project, regenerates commands
```

**Option 2: Manual Migration**
```bash
# Keep existing project commands
# Just remove global sc:* commands
# No change needed
```

### For New Projects

```bash
cd new-project
claude
/init
# Automatically generates adapted commands
# No global sc:* commands needed
```

---

## Benefits

### Token Efficiency
- **Current**: ~44k tokens (global + project commands)
- **Vision**: ~10-15k tokens (project-adapted only)
- **Savings**: ~20-30k tokens per session (45-68% reduction)

### Perfect Fit
- Commands match the exact stack you're using
- No React commands in Python projects
- No Python commands in React projects
- Domain-specific research guidance

### Maintainability
- Update templates once, all new projects benefit
- Easy to add new stack templates
- Community can contribute templates

### Flexibility
- Projects can override generated commands
- Easy to customize per-project needs
- Templates serve as starting point

---

## Success Metrics

### Technical
- [ ] /init generates commands in <30 seconds
- [ ] 95%+ stack detection accuracy
- [ ] ~20-30k token savings per project
- [ ] Zero global command redundancy

### User Experience
- [ ] Commands feel "native" to project
- [ ] No confusion about which command to use
- [ ] Onboarding faster with generated commands
- [ ] Easy to extend/customize

---

## Risks & Mitigations

### Risk 1: Detection Failures
**Mitigation**: Fallback to generic templates, allow manual override

### Risk 2: Template Maintenance
**Mitigation**: Start with 3-5 common stacks, expand gradually

### Risk 3: Breaking Existing Workflows
**Mitigation**: Migration is opt-in, existing commands continue working

### Risk 4: Over-Engineering
**Mitigation**: Start simple (3 templates), iterate based on usage

---

## Next Steps

### Immediate (This Session)
- [x] Document vision (this file)
- [x] Execute Option B optimization (remove global sc:* bloat)
- [ ] Get user approval for execution

### Short-term (Next 1-2 weeks)
- [ ] Create 3 initial templates:
  - python-tdd (for scholardoc-like projects)
  - react-frontend (for React projects)
  - django-api (for Django projects)
- [ ] Rewrite /project:init with detection engine
- [ ] Test with scholardoc regeneration

### Medium-term (1-3 months)
- [ ] Add 5-10 more stack templates
- [ ] Community template contribution system
- [ ] Template marketplace/registry

### Long-term (3-6 months)
- [ ] AI-powered template generation from project analysis
- [ ] Cross-project command learning
- [ ] Automatic template updates

---

## Example: Full Workflow

```bash
# New React project
cd ~/projects/my-new-react-app
npm create vite@latest . -- --template react-ts
npm install

# Initialize Claude Code with smart detection
claude
/init

# Output:
"""
ðŸ” Analyzing project...
   âœ“ Detected: React 18 + TypeScript
   âœ“ Test framework: Vitest + React Testing Library
   âœ“ Build tool: Vite
   âœ“ No MCP servers currently needed

ðŸ“ Generating commands from template: react-frontend
   âœ“ /project:implement - React component workflow
   âœ“ /project:component - Storybook component creation
   âœ“ /project:test - Vitest + RTL testing
   âœ“ /project:improve - Code quality workflow
   âœ“ /project:research - Frontend tech research

ðŸŽ¨ MCP Servers:
   âœ“ Magic MCP - UI component generation
   âœ“ Context7 MCP - React documentation

âœ… Project initialized! 5 commands ready, 10.2k tokens loaded.

Global overhead: 3.5k tokens (help, load, save)
Total: 13.7k tokens (vs 44k with old approach)

Try: /project:component "UserProfile card"
"""

# Use generated command
/project:component "UserProfile card"

# Claude:
# 1. Activates Magic MCP for UI generation
# 2. Uses Context7 for React best practices
# 3. Creates component with TypeScript
# 4. Generates Storybook story
# 5. Creates test file with RTL
# 6. Everything perfectly adapted to THIS project!
```

---

## Conclusion

This architectural vision transforms the plugin system from:
- **One-size-fits-all global commands** (bloated, redundant)
- **To project-adapted commands** (lean, perfect-fit)

**Result**:
- 45-68% token reduction
- Commands that feel native to each project
- Maintainable through templates
- Scalable to any stack

**Implementation**: Start small (3 templates), iterate based on real usage.

**Status**: Vision documented, ready for incremental implementation after Option B optimization.
